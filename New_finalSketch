#include <util/delay.h>
#include <avr/io.h>

#define F_CPU 16000000UL         // Clock speed

// Updated Pin Definitions for WOWKI design
#define TRIG_PIN PD3             // Trigger pin assigned to Arduino pin 3
#define ECHO_PIN PD2             // Echo pin assigned to Arduino pin 2
#define SERVO_PIN PB1            // Servo motor control pin (Arduino pin 9)

#define D1 40  // Reference distance for US sensor
// Servo and Distance Parameters
#define MIN_SERVO_ANGLE 0         // Minimum servo angle
#define MAX_SERVO_ANGLE 180       // Maximum servo angle
#define DISTANCE_THRESHOLD 30     //(cm) Adjust based on testing results

#define HOVER_FAN_PIN PD4        // Hover fan (Fan 1) - On/Off
#define PROPULSION_FAN_PIN PD6   // Propulsion fan (Fan 2) - PWM (0C0A)

#define constrain(x, a, b) ((x)<(a)?(a):((x)>(b)?(b):(x)))

// Global variables
volatile unsigned long milliseconds = 0; // Millisecond counter for timing
uint16_t servo_angle = 90; // Initialize to middle position
enum State { INIT, IDLE, SCAN, MOVE };
State currentState = INIT;
float currentSpeed = 0;

// Function Prototypes
void setup();
void servo_write(uint16_t angle);
void setupPWM();

// Timer interrupt for custom millis
ISR(TIMER1_COMPA_vect) {
    milliseconds++;
}

void setup() {
    // Initialize Timer2 for millisecond timing
    TCCR2A = (1 << WGM21);        // CTC mode
    OCR2A = 249;                   // 1 ms interrupt at 16 MHz with prescaler 64
    TIMSK2 = (1 << OCIE2A);       // Enable Timer2 compare match interrupt
    TCCR2B = (1 << CS22);         // Prescaler 64
    
    // Rest of your setup code...
    Serial.begin(9600);
    Serial.println("CURRENT STATE INIT");

    // Set pin directions
    DDRD |= (1 << TRIG_PIN);      // TRIG_PIN output
    DDRD &= ~(1 << ECHO_PIN);     // ECHO_PIN input
    DDRD |= (1 << HOVER_FAN_PIN); // Hover fan output
    DDRD |= (1 << PROPULSION_FAN_PIN); // Propulsion fan output
    DDRB |= (1 << SERVO_PIN);     // Servo output

    setupPWM();
    servo_write(90);  // Center the servo
    _delay_ms(1000);  // Allow everything to stabilize
    
    currentState = IDLE;
}

void servo_write(uint16_t angle) {
    // Constrain angle to 0-180
    angle = constrain(angle, 0, 180);
    
    // Convert angle to pulse width (900-2100 microseconds)
    // 900µs = 1800 timer ticks, 2100µs = 4200 timer ticks
    uint16_t pulse_width = 1000 + ((4000 * (uint32_t)angle) / 180);
    pulse_width = constrain(pulse_width, 1000, 5000);
    
    
    // Update PWM compare value
    OCR1A = pulse_width;
    
    // Debug output
    Serial.print("Angle: ");
    Serial.print(angle);
    Serial.print(" Pulse width: ");
    Serial.println(pulse_width);
}

//US sensor distance function
long measureUltrasonicDistance() {
    long duration; 
    int distance;  

    // Correct PORT usage for TRIG_PIN (PD3)
    PORTD &= ~(1 << TRIG_PIN); 
    _delay_us(2); 
    PORTD |= (1 << TRIG_PIN); 
    _delay_us(10); 
    PORTD &= ~(1 << TRIG_PIN); 

    duration = pulseIn(ECHO_PIN, HIGH); 
    distance = duration * 0.0344 / 2; 

    return distance; 
}

void setupPWM() {
    // Configure Timer1 for PWM generation
    // Fast PWM mode with ICR1 as TOP
    TCCR1A = (1 << COM1A1) | (1 << WGM11);
    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
    
    // Set PWM frequency to 50Hz (20ms period)
    ICR1 = 39999;  // = 16MHz/(8 * 50Hz) - 1
    
    // Initialize servo to middle position
    OCR1A = 3000;  // ~1.5ms pulse (90 degrees)
}

void delay_ms(unsigned int ms) {
    unsigned long start = customMillis();
    while (customMillis() - start < ms);
}

void delay_us(unsigned int us) {
    while (us--) {
        _delay_us(1); // Use built-in function for accuracy
    }
}

unsigned long customMillis() {
    unsigned long ms;
    cli();
    ms = milliseconds;
    sei();
    return ms;
}

//Above only servo and us
bool isObstacleDetected(){
long distance = measureUltrasonicDistance();
if(distance < D1){
return 1; //obstacle detected 
}
else{
return 0;
}
}

void scanEnvironment() {
    // Print distance for debugging
    long distance = measureUltrasonicDistance();
    Serial.print("Distance: ");
    Serial.println(distance);
    
    // Move servo to scan for clear path
    servo_write(servo_angle);
    _delay_ms(200);  // Give servo time to move
    
    if (!isObstacleDetected()) {
        currentState = MOVE;
        return;
    }
    
    // Update servo angle for next scan
    if (servo_angle == 90) {
        servo_angle = 0;
    } else if (servo_angle == 0) {
        servo_angle = 180;
    } else if (servo_angle == 180) {
        servo_angle = 90;
    }
    
    // Stay in SCAN state
    currentState = SCAN;
}

void startHoverFan(){
PORTD |= (1 << HOVER_FAN_PIN); // Set PD4 high to turn on hover fan
}

void stopHoverFan() {
    PORTD &= ~(1 << HOVER_FAN_PIN); // Set PD4 low to turn off hover fan
}

void startPropulsionFan(uint8_t dutyCycle) {
    static uint8_t timerInitialized = 0;
    if (!timerInitialized) {
        // Configure Timer2 for Fast PWM, 8-bit mode
        TCCR2A |= (1 << WGM20) | (1 << WGM21);   // Fast PWM
        TCCR2A |= (1 << COM2A1);                // Non-inverting mode on OC2A
        TCCR2B |= (1 << CS21) | (1 << CS20);    // Prescaler 64 (~490 Hz)
        timerInitialized = 1;
    }
    OCR2A = dutyCycle; // Set duty cycle (0-255)
}

void stopPropulsionFan() {
    OCR2A = 0; // Set duty cycle to 0 to stop propulsion fan
}

void handleState() {
    Serial.print("Current State: ");
    Serial.println(currentState);
    
    switch(currentState) {
        case INIT:
            setup();
            currentState = IDLE;
            break;
            
        case IDLE:
            stopPropulsionFan();
            stopHoverFan();
            _delay_ms(1000);
            currentState = SCAN;
            break;
            
        case SCAN:
            stopPropulsionFan();
            stopHoverFan();
            scanEnvironment();  // This will update state to MOVE if path is clear
            break;
            
        case MOVE:
            if (isObstacleDetected()) {
                currentState = SCAN;
                break;
            }
            startHoverFan();
            startPropulsionFan(255);
            _delay_ms(1000);  // Move for a short time before checking again
            break;
    }
}

void loop(){
  handleState();

}

int main(void) {
    cli();  // Disable interrupts during setup
    setup();
    sei();  // Enable interrupts
    
    while(1) {  // Infinite loop
        loop();
    }
    
    return 0;  // Never reached
}
