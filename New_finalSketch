#include <util/delay.h>
#include <avr/io.h>

#define F_CPU 16000000UL         // Clock speed

// Updated Pin Definitions for WOWKI design
#define TRIG_PIN PD3             // Trigger pin assigned to Arduino pin 3
#define ECHO_PIN PD2             // Echo pin assigned to Arduino pin 2
#define SERVO_PIN PB1            // Servo motor control pin (Arduino pin 9)

#define D1 40  // Reference distance for US sensor
// Servo and Distance Parameters
#define MIN_SERVO_ANGLE 0         // Minimum servo angle
#define MAX_SERVO_ANGLE 180       // Maximum servo angle
#define DISTANCE_THRESHOLD 30     //(cm) Adjust based on testing results

#define HOVER_FAN_PIN PD4        // Hover fan (Fan 1) - On/Off
#define PROPULSION_FAN_PIN PD6   // Propulsion fan (Fan 2) - PWM (0C0A)

#define constrain(x, a, b) ((x)<(a)?(a):((x)>(b)?(b):(x)))

// Global variables
volatile unsigned long milliseconds = 0; // Millisecond counter for timing
uint16_t servo_angle = 90; // Initialize to middle position
enum State { INIT, IDLE, SCAN, MOVE };
State currentState = INIT;
float currentSpeed = 0;

// Function Prototypes
void setup();
void servo_write(uint16_t angle);
void setupPWM();

// Timer interrupt for custom millis
ISR(TIMER1_COMPA_vect) {
    milliseconds++;
}

void setup() {
    // Initialize Timer1 for millisecond timing
    TCCR1A = (1 << WGM11);        // CTC mode
    OCR1A = 249;                  // 1 ms interrupt at 16 MHz with prescaler 64
    TIMSK1 = (1 << OCIE1A);       // Enable Timer1 compare match interrupt
    TCCR1B = (1 << CS11) | (1 << CS10); // Prescaler 64
    
    Serial.begin(9600);
    Serial.println("CURRENT STATE INIT");

    // Set TRIG_PIN as output, ECHO_PIN as input
    DDRD |= (1 << TRIG_PIN);  // TRIG_PIN (PD3) output
    DDRD &= ~(1 << ECHO_PIN); // ECHO_PIN (PD2) input

    // Setup Servo pin (PB1 - Arduino pin 9)
    DDRB |= (1 << SERVO_PIN); // Set PB1 (Arduino pin 9) as output for servo control
    servo_write((uint16_t)servo_angle);
    _delay_ms(1000);  // Allow sensor to stabilize

    setupPWM();
    
    currentSpeed = 255;
    currentState = IDLE;
}

// Main Function
int main() {

}

void servo_write(uint16_t angle) {
    // Constrain angle to 0-180
    angle = constrain(angle, 0, 180);
    
    // Convert angle to pulse width (900-2100 microseconds)
    // 900µs = 1800 timer ticks, 2100µs = 4200 timer ticks
    uint16_t pulse_width = 1000 + ((4000 * (uint32_t)angle) / 180);
    pulse_width = constrain(pulse_width, 1000, 5000);
    
    
    // Update PWM compare value
    OCR1A = pulse_width;
    
    // Debug output
    Serial.print("Angle: ");
    Serial.print(angle);
    Serial.print(" Pulse width: ");
    Serial.println(pulse_width);
}

//US sensor distance function
long measureUltrasonicDistance() {
    long duration; 
    int distance;  

    PORTB &= ~(1 << TRIG_PIN); 
    _delay_us(2); 
    PORTB |= (1 << TRIG_PIN); 
    _delay_us(10); 
    PORTB &= ~(1 << TRIG_PIN); 

    duration = pulseIn(ECHO_PIN, HIGH); 
    distance = duration * 0.0344 / 2; 

    return distance; 
}

void setupPWM() {
    // Configure Timer1 for PWM generation
    // Fast PWM mode with ICR1 as TOP
    TCCR1A = (1 << COM1A1) | (1 << WGM11);
    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
    
    // Set PWM frequency to 50Hz (20ms period)
    ICR1 = 39999;  // = 16MHz/(8 * 50Hz) - 1
    
    // Initialize servo to middle position
    OCR1A = 3000;  // ~1.5ms pulse (90 degrees)
}

void delay_ms(unsigned int ms) {
    unsigned long start = customMillis();
    while (customMillis() - start < ms);
}

void delay_us(unsigned int us) {
    while (us--) {
        _delay_us(1); // Use built-in function for accuracy
    }
}

unsigned long customMillis() {
    unsigned long ms;
    cli();
    ms = milliseconds;
    sei();
    return ms;
}

//Above only servo and us
bool isObstacleDetected(){
long distance = measureUltrasonicDistance();
if(distance < D1){
return 1; //obstacle detected 
}
else{
return 0;
}
}

void scanEnvironment() {
    while (isObstacleDetected()) {
        servo_write(servo_angle);
        if (servo_angle == 90 || servo_angle == 0) {
            servo_angle += 90;
        } else if (servo_angle == 180) {
            servo_angle -= 180;
        }
    }
    currentState = MOVE;
}

void startHoverFan(){
PORTD |= (1 << HOVER_FAN_PIN); // Set PD4 high to turn on hover fan
}

void stopHoverFan() {
    PORTD &= ~(1 << HOVER_FAN_PIN); // Set PD4 low to turn off hover fan
}

void startPropulsionFan(uint8_t dutyCycle) {
    static uint8_t timerInitialized = 0;
    if (!timerInitialized) {
        // Configure Timer2 for Fast PWM, 8-bit mode
        TCCR2A |= (1 << WGM20) | (1 << WGM21);   // Fast PWM
        TCCR2A |= (1 << COM2A1);                // Non-inverting mode on OC2A
        TCCR2B |= (1 << CS21) | (1 << CS20);    // Prescaler 64 (~490 Hz)
        timerInitialized = 1;
    }
    OCR2A = dutyCycle; // Set duty cycle (0-255)
}

void stopPropulsionFan() {
    OCR0A = 0; // Set duty cycle to 0 to stop propulsion fan
}

void handleState(){
  switch(currentState){
    case INIT:
  setup();
  currentState=IDLE;
  break;
    case IDLE:
      stopPropulsionFan();
      stopHoverFan();
      _delay_ms(1000);
      currentState=SCAN;
      break;
    case SCAN:
      stopPropulsionFan();
      stopHoverFan();
      scanEnvironment();
      currentState=MOVE;
    break;
    case MOVE:
      startHoverFan();
      startPropulsionFan(255);
      _delay_ms(4000);

      while(isObstacleDetected()==1){
  currentState=SCAN;
} 
//if(isGoalDetected()){currentState=STOP;} 
//break;
    //case STOP:
  //stopPropulsionFan();
  //stopHoverFan();
  //break;
  }
}
void loop(){
  handleState();

}

int main(void) {
    cli();  // Disable interrupts during setup
    setup();
    sei();  // Enable interrupts
    
    while(1) {  // Infinite loop
        loop();
    }
    
    return 0;  // Never reached
}
