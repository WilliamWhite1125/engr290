#include <util/delay.h>
#include <avr/io.h>

#define F_CPU 16000000UL         // Clock speed

// Updated Pin Definitions for WOWKI design
#define TRIG_PIN PD3             // Trigger pin assigned to Arduino pin 3
#define ECHO_PIN PD2             // Echo pin assigned to Arduino pin 2
#define SERVO_PIN PB1            // Servo motor control pin (Arduino pin 9)

#define D1 40  // Reference distance for US sensor
// Servo and Distance Parameters
#define MIN_SERVO_ANGLE 0         // Minimum servo angle
#define MAX_SERVO_ANGLE 180       // Maximum servo angle
#define DISTANCE_THRESHOLD 30     //(cm) Adjust based on testing results

#define constrain(x, a, b) ((x)<(a)?(a):((x)>(b)?(b):(x)))

// Global variables
volatile unsigned long milliseconds = 0; // Millisecond counter for timing
float servo_angle = 90.0; // Initialize to middle position
enum State { INIT, IDLE, SCAN, MOVE };
State currentState = INIT;
float currentSpeed = 0;

// Function Prototypes
void setup();
void servo_write(uint16_t angle);
void setupPWM();

// Timer interrupt for custom millis
ISR(TIMER1_COMPA_vect) {
    milliseconds++;
}

void setup() {
    // Initialize Timer1 for millisecond timing
    TCCR1A = (1 << WGM11);        // CTC mode
    OCR1A = 249;                  // 1 ms interrupt at 16 MHz with prescaler 64
    TIMSK1 = (1 << OCIE1A);       // Enable Timer1 compare match interrupt
    TCCR1B = (1 << CS11) | (1 << CS10); // Prescaler 64
    
    Serial.begin(9600);
    Serial.println("CURRENT STATE INIT");

    // Set TRIG_PIN as output, ECHO_PIN as input
    DDRD |= (1 << TRIG_PIN);  // TRIG_PIN (PD3) output
    DDRD &= ~(1 << ECHO_PIN); // ECHO_PIN (PD2) input

    // Setup Servo pin (PB1 - Arduino pin 9)
    DDRB |= (1 << SERVO_PIN); // Set PB1 (Arduino pin 9) as output for servo control
    servo_write((uint16_t)servo_angle);
    _delay_ms(1000);  // Allow sensor to stabilize

    setupPWM();
    
    currentSpeed = 255;
    currentState = IDLE;
}

// Main Function
int main() {
    setup();
    while (1) {
        servo_write(0);
        _delay_ms(3000);
        servo_write(90);
        _delay_ms(3000);
        servo_write(180);
        _delay_ms(3000);

    }
    return 0; // Not reached
}

void servo_write(uint16_t angle) {
    // Constrain angle to 0-180
    angle = constrain(angle, 0, 180);
    
    // Convert angle to pulse width (900-2100 microseconds)
    // 900µs = 1800 timer ticks, 2100µs = 4200 timer ticks
    uint16_t pulse_width = 1000 + ((4000 * (uint32_t)angle) / 180);
    pulse_width = constrain(pulse_width, 1000, 5000);
    
    
    // Update PWM compare value
    OCR1A = pulse_width;
    
    // Debug output
    Serial.print("Angle: ");
    Serial.print(angle);
    Serial.print(" Pulse width: ");
    Serial.println(pulse_width);
}

//US sensor distance function
long measureUltrasonicDistance() {
    long duration; 
    int distance;  

    PORTB &= ~(1 << TRIG_PIN); 
    _delay_us(2); 
    PORTB |= (1 << TRIG_PIN); 
    _delay_us(10); 
    PORTB &= ~(1 << TRIG_PIN); 

    duration = pulseIn(ECHO_PIN, HIGH); 
    distance = duration * 0.0344 / 2; 

    return distance; 
}

void setupPWM() {
    // Configure Timer1 for PWM generation
    // Fast PWM mode with ICR1 as TOP
    TCCR1A = (1 << COM1A1) | (1 << WGM11);
    TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);
    
    // Set PWM frequency to 50Hz (20ms period)
    ICR1 = 39999;  // = 16MHz/(8 * 50Hz) - 1
    
    // Initialize servo to middle position
    OCR1A = 3000;  // ~1.5ms pulse (90 degrees)
}

void delay_ms(unsigned int ms) {
    unsigned long start = customMillis();
    while (customMillis() - start < ms);
}

void delay_us(unsigned int us) {
    while (us--) {
        _delay_us(1); // Use built-in function for accuracy
    }
}

unsigned long customMillis() {
    unsigned long ms;
    cli();
    ms = milliseconds;
    sei();
    return ms;
}

//Above only servo and us
bool isObstacleDetected(){
long distance = measureUltrasonicDistance();
if(distance < D1){
return 1; //obstacle detected 
}
else{
return 0;
}
}

void scanEnvironment(){
while(isObstacleDetected()==1){
servo_write(servo_angle);
isObstacleDetected();
if(servo_angle==90||servo_angle==0){
servo_angle=servo_angle+90;
}
else if(servo_angle==180){
servo_angle=servo_angle-180;
}
}
else {
currentState=MOVE;
}
}


